<!DOCTYPE html>

<html>
<head>
  <title>help-esb.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>help-esb.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(root, factory)</span> </span>{
<span class="hljs-pi">  'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Setup HelpEsb appropriately for the environment.  Dependency on net likely
means this only works on Node.js, but meh.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  factory(
    exports,
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>),
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>).EventEmitter,
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>),
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>),
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>),
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'uuid'</span>),
    <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
  );
}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(HelpEsb, net, EventEmitter, util, url, Promise, uuid, _)</span> </span>{
<span class="hljs-pi">  'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="helpesb-client">HelpEsb.Client</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h3 id="helpesb-client-constructor-">HelpEsb.Client <em>constructor</em></h3>
<p>The client connects to the ESB running on the given host/port.  You will
need to <a href="#helpesb-client-login">login</a> before doing anything over the
connection.</p>
<pre><code><span class="hljs-keyword">var</span> client = Esb.Client(<span class="hljs-string">'tcp://example.com:1234'</span>);
client.login(<span class="hljs-string">'clientName'</span>);
client.subscribe(<span class="hljs-string">'subscriptionChannel1'</span>);
client.on(<span class="hljs-string">'type.error'</span>, <span class="hljs-built_in">console</span>.error);
client.on(<span class="hljs-string">'group.subscriptionChannel1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
  <span class="hljs-comment">// Process data</span>
});
</code></pre><p>Or using the RPC conventions:</p>
<pre><code><span class="hljs-keyword">var</span> client = Esb.Client(<span class="hljs-string">'tcp://example.com:1234'</span>);
client.login(<span class="hljs-string">'clientName'</span>);
client.rpcReceive(<span class="hljs-string">'subscriptionChannel1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
  <span class="hljs-comment">// Process data</span>
  <span class="hljs-keyword">return</span> result;
});
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Extend EventEmitter to handle events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    EventEmitter.call(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">var</span> uriObj = url.parse(uri);</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>This uses the basic socket connection to the ESB.  We are forcing utf-8
here as we shouldn’t really use anything else.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._socket = Promise.promisifyAll(
      net.createConnection({host: uriObj.hostname, port: uriObj.port})
    );
    <span class="hljs-keyword">this</span>._socket.setEncoding(<span class="hljs-string">'utf-8'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>We can’t send anything over the socket until we have a connection.  We
immediately initiate the connection and save a promise for it so that
the client ensures the connection exists before trying to send data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._socketConnection = <span class="hljs-keyword">this</span>._socket.onAsync(<span class="hljs-string">'connect'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Handle data coming in over the socket using our special handler.
Because data can come in pieces, we have to keep a data buffer so that
we only process complete payloads.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._buffer = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>._socket.on(<span class="hljs-string">'data'</span>, <span class="hljs-keyword">this</span>._handleData.bind(<span class="hljs-keyword">this</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Error handling is a bit simpler - we can just pass the error to the
user’s configured error handler.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._socket.on(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">this</span>.emit.bind(<span class="hljs-keyword">this</span>, <span class="hljs-string">'type.error'</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Start with no authentication and no subscriptions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._authentication = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>._subscriptions = {};
  };

  util.inherits(HelpEsb.Client, EventEmitter);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h3 id="helpesb-client-login">HelpEsb.Client.login</h3>
<p>Login to the ESB using the given credentials (name only right now).
Returns a promise that gets resolved when successfully logged in.  This
same promise is kept internally as well for controlling when further
requests can be sent.</p>
<pre><code>client.login(<span class="hljs-string">'clientName'</span>);
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype.login = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._authentication = <span class="hljs-keyword">this</span>._rpcSend({
      meta: {type: <span class="hljs-string">'login'</span>},
      data: {name: name, subscriptions: []}
    }).timeout(<span class="hljs-number">5000</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h3 id="helpesb-client-subscribe">HelpEsb.Client.subscribe</h3>
<p>Subscribe to an ESB group.  This returns a
<a href="https://github.com/petkaantonov/bluebird">promise</a> of the send event so
you can do additional tasks after the subscription has been sent.</p>
<pre><code>client.subscribe(<span class="hljs-string">'a'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Subscribed!'</span>);
});
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype.subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>._subscriptions[group] === <span class="hljs-string">'undefined'</span>) {
      <span class="hljs-keyword">this</span>._subscriptions[group] = <span class="hljs-keyword">this</span>._authentication.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._rpcSend({
          meta: {type: <span class="hljs-string">'subscribe'</span>},
          data: {channel: group}
        }).timeout(<span class="hljs-number">5000</span>);
      }.bind(<span class="hljs-keyword">this</span>));
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._subscriptions[group];
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h3 id="helpesb-client-send">HelpEsb.Client.send</h3>
<p>Sends a payload message to the ESB with the given data.  Returns a promise
that, like the <a href="#helpesb-client-subscribe">subscribe</a> call, is fulfilled
when the message is sent, but does not indicate whether the message was
received by the ESB or by any subscribers.  For RPC-esque behavior, use
<a href="#helpesb-client-rpcsend">rpcSend</a>.</p>
<pre><code>client.send(<span class="hljs-string">'target'</span>, {id: <span class="hljs-number">1234</span>, message: <span class="hljs-string">'Hello!'</span>});
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group, data, replyCallback)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._authentication.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._send(
        {meta: {type: <span class="hljs-string">'sendMessage'</span>, group: group}, data: data},
        replyCallback
      );
    }.bind(<span class="hljs-keyword">this</span>));
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h3 id="helpesb-client-rpcsend">HelpEsb.Client.rpcSend</h3>
<p>Sends the packet like <a href="#helpesb-client-send">send</a>, but returns a promise
for a response from some other service.  This uses the autogen message id
and relies on the other service properly publishing a message with a
proper replyTo.</p>
<p>Automatically subscribes to the result group for you if not already
subscribed.</p>
<pre><code>client.rpcSend(<span class="hljs-string">'foo'</span>, {name: <span class="hljs-string">'John'</span>}).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response)</span> </span>{
  <span class="hljs-built_in">console</span>.log(response);
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
  <span class="hljs-built_in">console</span>.error(error);
});
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype.rpcSend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group, data)</span> </span>{
    <span class="hljs-keyword">var</span> send = Promise.promisify(HelpEsb.Client.prototype.send).bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscribe(group + <span class="hljs-string">'-result'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> send(group, data).spread(<span class="hljs-keyword">this</span>._checkRpcResult);
    }.bind(<span class="hljs-keyword">this</span>));
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h3 id="helpesb-client-rpcreceive">HelpEsb.Client.rpcReceive</h3>
<p>Listen on the given group like <a href="#helpesb-client-on">on</a>, and call the
given callback with any messages.  The value returned by the callback is
sent to the GROUPNAME-result group in reply to the incoming message.</p>
<p>Automatically subscribes to the group for you if not already subscribed.</p>
<pre><code>client.rpcReceive(<span class="hljs-string">'foo'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
  <span class="hljs-keyword">return</span> {greeting: <span class="hljs-string">'Hello '</span> + (data.name || <span class="hljs-string">'Stranger'</span>)};
});
</code></pre><p>If the callback returns a promise, the result of the promise is sent.</p>
<pre><code>client.rpcReceive(<span class="hljs-string">'foo'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
  <span class="hljs-keyword">return</span> request.getAsync(<span class="hljs-string">'http://www.google.com'</span>);
});
</code></pre><p>Errors are also handled and errors are sent as the “reason” through the
ESB.</p>
<pre><code>client.rpcReceive(<span class="hljs-string">'foo'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not implemented!'</span>);
});
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype.rpcReceive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(group, cb)</span> </span>{
    <span class="hljs-keyword">this</span>.subscribe(group);
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'group.'</span> + group, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, incomingMeta)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Link up our reply to the incoming request but on the “result” group.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> meta = {
        type: <span class="hljs-string">'sendMessage'</span>,
        group: group + <span class="hljs-string">'-result'</span>,
        replyTo: incomingMeta.id
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Catch thrown errors so that we can send the result through the ESB.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> result = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">try</span> {
        result = Promise.resolve(cb(data));
      } <span class="hljs-keyword">catch</span>(e) {
        result = Promise.reject(e.toString());
      }

      result.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._send(
          {meta: _.extend({result: <span class="hljs-string">'SUCCESS'</span>}, meta), data: data}
        );
      }.bind(<span class="hljs-keyword">this</span>)).catch(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._send(
          {
            meta: _.extend({result: <span class="hljs-string">'FAILURE'</span>, reason: error}, meta),
            data: data
          }
        );
      }.bind(<span class="hljs-keyword">this</span>));
    }.bind(<span class="hljs-keyword">this</span>));
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h3 id="helpesb-client-close">HelpEsb.Client.close</h3>
<p>Closes the connection, ending communication.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype.close = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>._socket.end();
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h3 id="private-methods">Private Methods</h3>

            </div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Format the packet for the ESB and send it over the socket.  JSON encodes
the message and appends a newline as the delimiter between messages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype._send = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(packet, replyCallback)</span> </span>{
    packet = <span class="hljs-keyword">this</span>._massageOutboundPacket(packet);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Register a callback for replies to this message if a callback is given.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (replyCallback) {
      <span class="hljs-keyword">this</span>.once(<span class="hljs-string">'replyTo.'</span> + packet.meta.id, _.partial(replyCallback, <span class="hljs-literal">null</span>));
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._sendRaw(<span class="hljs-built_in">JSON</span>.stringify(packet) + <span class="hljs-string">'\n'</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Sends the packet like <strong>_send</strong>, but returns a promise for a response from
some other service.  This uses the autogen message id and relies on the
other service properly publishing a message with a proper replyTo.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype._rpcSend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(packet)</span> </span>{
    <span class="hljs-keyword">var</span> send = Promise.promisify(HelpEsb.Client.prototype._send).bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> send(packet).spread(<span class="hljs-keyword">this</span>._checkRpcResult);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Checks an RPC response and fails the promise if the response is not
successful.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype._checkRpcResult = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, meta)</span> </span>{
    <span class="hljs-keyword">if</span> (meta.result !== <span class="hljs-string">'SUCCESS'</span>) {
      <span class="hljs-keyword">return</span> Promise.reject(meta.reason);
    }

    <span class="hljs-keyword">return</span> Promise.resolve(data);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Wait on the socket connection and once it is avaialable send the given
string data returning a promise of the data being sent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype._sendRaw = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._socketConnection.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._socket.writeAsync(data);
    }.bind(<span class="hljs-keyword">this</span>));
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Handle an incoming slice of data over the socket.  Split the message on
the newline delimiters and pass each complete packet to <code>_handlePacket</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype._handleData = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Continue to append to the buffer.  The full message may not come in one
piece.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._buffer += data;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._buffer.indexOf(<span class="hljs-string">'\n'</span>) !== -<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>It is even possible that multiple packets were sent at once and so we
need to make sure we parse all of them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> packets = <span class="hljs-keyword">this</span>._buffer.split(<span class="hljs-string">'\n'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>The section after the last newline (which may be empty) is kept in the
buffer as it belongs to the next packet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>._buffer = packets[packets.length - <span class="hljs-number">1</span>];

      packets.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).forEach(<span class="hljs-keyword">this</span>._handlePacket.bind(<span class="hljs-keyword">this</span>));
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Handles a single packet of data.  The data is expected to be JSON, and if
it isn’t, a <code>type.error</code> event will be emitted.  Otherwise, an event for
each of the meta fields (e.g., <code>type.error</code>, <code>group.someGroup</code>,
<code>replyTo.SOME_ID</code>) will be emitted.</p>
<p>In addition, non-error packets will be emitted to the <code>*</code> event and, if no
listeners were fired for the packet, to the <code>*.unhandled</code> event.</p>
<p>In the future, this will also be responsible for handling “special”
packets like heartbeats, etc. that are kept separate from the primary
payload packets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype._handlePacket = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(packet)</span> </span>{
    <span class="hljs-keyword">try</span> {
      packet = <span class="hljs-built_in">JSON</span>.parse(packet);
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'type.error'</span>, e);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (
      <span class="hljs-keyword">typeof</span> packet.meta !== <span class="hljs-string">'object'</span> ||
      <span class="hljs-keyword">typeof</span> packet.meta.type !== <span class="hljs-string">'string'</span> ||
      <span class="hljs-keyword">typeof</span> packet.data === <span class="hljs-string">'undefined'</span>
    ) {
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'type.error'</span>, <span class="hljs-string">'Invalid format detected for packet'</span>, packet);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> handled = _.map(packet.meta, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, key)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(key + <span class="hljs-string">'.'</span> + value, packet.data, packet.meta);
    }.bind(<span class="hljs-keyword">this</span>));

    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'*'</span>, packet.data, packet.meta);
    <span class="hljs-keyword">if</span> (!_.any(handled)) {
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'*.unhandled'</span>, packet.data, packet.meta);
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Process the packet to ensure it conforms to the ESB requirements.  Sets
the message id in the metadata for the packet if it wasn’t already set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  HelpEsb.Client.prototype._massageOutboundPacket = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(packet)</span> </span>{
    packet.meta.id = packet.meta.id || uuid.v4();

    <span class="hljs-keyword">return</span> packet;
  };

  <span class="hljs-keyword">return</span> HelpEsb;
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
